A02-01.2

int main (void) {    
    SystemInit(); 
    init_leds();
    init_PC09();    
    while (1)
    {
    	wait_mSek(1000);
    	green_LED_Toggle;
    }
}

A02-01.3
int main (void) {    
    // SystemInit(); 
    init_leds();
    init_PC09();    
    while (1)
    {
    	wait_mSek(1000);
    	green_LED_Toggle;
    }
}

A02-01.4
int main (void) {   
    SystemInit();
    
    init_PC09();    //einmal auskommentiert und einmal nicht
    init_tasten();

    while (1)
    {
    	if(taste1_downed()) {
    	    slowMode();
    	}
    	if(taste2_downed()) {
    	    fastMode();
    	}
    }
}

A02-02.1 (aus interrupts.c)
void SysTick_Handler(void) {
	
	...	

	// LED zyklisch schalten
	if( stc_led == 500 ) {
		green_LED_OFF;
	}
	else if( stc_led == 3500 ) {
		green_LED_ON;
		stc_led = 0;
	}
}


A02-02.2 (aus interrupts.c)
void SysTick_Handler(void)
{

	static unsigned long stc_timer = 0;
	stc_timer++;
	...
	//======================================================================
	// stc_timer und timer aus interrupts.h aktualisieren
	if(stc_timer > 99) {
		timer--;
		stc_timer = 0;
	}
}

A03-01.1
void init_usart_2_tx(void) {
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;

	// Taktsystem für die USART2 freigeben
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);


	// GPIO Port A Taktsystem freigeben
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

	// USART2 TX an PA2 mit Alternativfunktion Konfigurieren
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	// USART2 TX mit PA2 verbinden
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);

	// Datenprotokoll der USART einstellen
	/*
	 * Hardware Flow Control nur, wenn mit einem Emfpänger aktiv kommuniziert wird über CTS (Clear to send)
	 * RFR (Ready for Receiving, fälschlicherweise als RTS) Leitungen, die jede USART Unit bereit stellt.
	 * Tx Transmission, Rx Receiving. USART muss mit PIN verbunden werden.
	 */
	USART_InitStructure.USART_BaudRate 				= 921600;
	USART_InitStructure.USART_WordLength 			= USART_WordLength_8b;
	USART_InitStructure.USART_StopBits 				= USART_StopBits_1;
	USART_InitStructure.USART_Parity 				= USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl	= USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode 					= USART_Mode_Tx;
	USART_Init(USART2, &USART_InitStructure);

	// USART2 freigeben
	USART_Cmd(USART2, ENABLE); // enable USART2
}

int main ( void )

    init_tasten();
    init_leds();
    init_usart_2_tx();

    char send = '0';
    while (1)
    {
		USART_SendData(USART2, send);
		while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){}
		if(++send>'9') send = '0';
    }
}

A03-01.2

int main ( void ) {

    init_tasten();
    init_leds();
    init_usart_2_tx();

    char usart2_rx_buffer[50];
    char * usart2_tx_buffer = "Hallo Welt \r\n";

    while (1)
    {
        char * usart2_tx_buffer = "Hallo Welt \r\n";
    	usart_2_print(usart2_tx_buffer);
    }
}

void usart_2_print(char * str_print) {
	int i = 0;
	for(i = 0;i < strlen(str_print);i++)
	{
		USART_SendData(USART2, str_print[i]);
		while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){}
	}
}